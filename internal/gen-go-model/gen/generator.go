package gen

import (
	"fmt"
	"regexp"

	"github.com/dave/jennifer/jen"
	"github.com/duythinht/dbml-go/core"
	"github.com/duythinht/dbml-go/internal/gen-go-model/genutil"
)

type generator struct {
	dbml      *core.DBML
	out       string
	gopackage string
	types     map[string]jen.Code
}

func newgen(dbml *core.DBML, out string, gopackage string) *generator {
	return &generator{
		dbml:      dbml,
		out:       out,
		gopackage: gopackage,
		types:     make(map[string]jen.Code),
	}
}

func (g *generator) file() *jen.File {
	return jen.NewFilePathName(g.out, g.gopackage)
}

func (g *generator) generate() error {
	if err := g.genEnums(); err != nil {
		return err
	}
	return nil
}

func (g *generator) genEnums() error {
	for _, enum := range g.dbml.Enums {
		if err := g.genEnum(enum); err != nil {
			return err
		}
	}
	for _, table := range g.dbml.Tables {
		if err := g.genTable(table); err != nil {
			return err
		}
	}

	return nil
}

func (g *generator) genEnum(enum core.Enum) error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	originName := genutil.NormalizeTypeName(enum.Name)
	goTypeName := genutil.NormalizeGoTypeName(enum.Name)

	f.PackageComment("Code generated by dbml-gen-go-model. DO NOT EDIT.")
	f.PackageComment("Supported by duythinht@2020")
	f.Commentf("%s is generated type for enum '%s'", goTypeName, originName)
	f.Type().Id(goTypeName).Int()

	f.Const().DefsFunc(func(group *jen.Group) {
		group.Id("_").Id(goTypeName).Op("=").Iota()
		for _, value := range enum.Values {
			v := group.Id(genutil.NormalLizeGoName(value.Name))
			if value.Note != "" {
				v.Comment(value.Note)
			}
		}
	})

	g.types[enum.Name] = jen.Id(goTypeName)

	return f.Save(fmt.Sprintf("%s/%s.enum.go", g.out, genutil.Normalize(enum.Name)))
}

func (g *generator) genTable(table core.Table) error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	originName := genutil.NormalizeTypeName(table.Name)
	goTypeName := genutil.NormalizeGoTypeName(table.Name)

	f.PackageComment("Code generated by dbml-gen-go-model. DO NOT EDIT.")
	f.PackageComment("Supported by duythinht@2020")
	f.Commentf("%s is generated type for table '%s'", goTypeName, originName)

	var genColumnErr error

	cols := make([]string, 0)

	f.Type().Id(goTypeName).StructFunc(func(group *jen.Group) {
		for _, column := range table.Columns {
			columnName := genutil.NormalLizeGoName(column.Name)
			columnOriginName := genutil.Normalize(column.Name)
			t, ok := g.getJenType(column.Type)
			if !ok {
				genColumnErr = fmt.Errorf("type '%s' is not support!", column.Type)
			}
			if column.Settings.Note != "" {
				group.Comment(column.Settings.Note)
			}
			group.Id(columnName).Add(t).Tag(map[string]string{
				"json":         columnOriginName,
				"db":           columnOriginName,
				"gorm":         columnOriginName,
				"mapstructure": columnOriginName,
			})
			cols = append(cols, columnOriginName)
		}
	})

	if genColumnErr != nil {
		return genColumnErr
	}

	f.Commentf("Columns return list columns's name for table '%s'", goTypeName)
	f.Func().Params(
		jen.Op("*").Id(goTypeName),
	).Id("Columns").Params().Index().String().Block(
		jen.Return(jen.Index().String().ValuesFunc(func(g *jen.Group) {
			for _, col := range cols {
				g.Lit(col)
			}
		})),
	)

	f.Commentf("DataColumns return list columns's name for table '%s' except 'id' columns", goTypeName)
	f.Func().Params(
		jen.Op("*").Id(goTypeName),
	).Id("DataColumns").Params().Index().String().Block(
		jen.Return(jen.Index().String().ValuesFunc(func(g *jen.Group) {
			for _, col := range cols {
				if col != "id" && col != "ID" && col != "Id" {
					g.Lit(col)
				}
			}
		})),
	)

	return f.Save(fmt.Sprintf("%s/%s.table.go", g.out, genutil.Normalize(table.Name)))
}

const primeTypePattern = `^(\w+)(\(d+\))?`

var (
	regexType    = regexp.MustCompile(primeTypePattern)
	builtinTypes = map[string]jen.Code{
		"int":       jen.Int(),
		"int8":      jen.Int8(),
		"int16":     jen.Int16(),
		"int32":     jen.Int32(),
		"int64":     jen.Int64(),
		"bigint":    jen.Int64(),
		"uint":      jen.Uint(),
		"uint8":     jen.Uint8(),
		"uint16":    jen.Uint16(),
		"uint32":    jen.Uint32(),
		"uint64":    jen.Uint64(),
		"float":     jen.Float64(),
		"float32":   jen.Float32(),
		"float64":   jen.Float64(),
		"bool":      jen.Bool(),
		"text":      jen.String(),
		"varchar":   jen.String(),
		"char":      jen.String(),
		"byte":      jen.Byte(),
		"rune":      jen.Rune(),
		"timestamp": jen.Int(),
		"datetime":  jen.Qual("time", "Time"),
	}
)

func (g *generator) getJenType(s string) (jen.Code, bool) {
	m := regexType.FindStringSubmatch(s)
	if len(m) >= 2 {
		// lookup for builtin type
		if t, ok := builtinTypes[m[1]]; ok {
			return t, ok
		}
	}
	t, ok := g.types[s]
	return t, ok
}
